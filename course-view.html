<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Watch Lesson | OneOrigin Hub</title>
    <style>
        .ico {
            width: 1em;
            height: 1em;
            fill: currentColor;
            vertical-align: -0.125em;
            padding: 0.22em;
            border-radius: 999px;
            background:
                radial-gradient(120% 120% at 28% 22%, rgba(255,255,255,0.60) 0%, rgba(255,255,255,0.18) 26%, rgba(0,0,0,0.10) 62%, rgba(0,0,0,0.22) 100%),
                linear-gradient(145deg, rgba(255,255,255,0.22), rgba(0,0,0,0.22)),
                rgba(66,133,244,0.16);
            border: 1px solid rgba(66,133,244,0.26);
            box-sizing: content-box;
            box-shadow:
                0 14px 26px rgba(0,0,0,0.42),
                0 2px 0 rgba(255,255,255,0.06),
                inset 0 1px 0 rgba(255,255,255,0.55),
                inset 0 -6px 12px rgba(0,0,0,0.34);
        }
        .ico.success { background: rgba(76,175,80,0.16); border-color: rgba(76,175,80,0.30); color: #4CAF50; }
        body { background-color: #0d1117; color: #c9d1d9; font-family: 'Segoe UI', sans-serif; text-align: center; padding: 20px; }
        .container { max-width: 900px; margin: auto; }
        
        /* Fixed: Restored 16:9 widescreen dimensions */
        .video-wrapper { 
            position: relative; 
            padding-bottom: 56.25%; /* Perfect 16:9 Ratio */
            height: 0; 
            margin: 20px 0; 
            background: #000;
            border-radius: 12px;
            border: 1px solid #30363d;
            overflow: hidden;
        }
        .video-wrapper iframe, .video-wrapper div#player { 
            position: absolute; top:0; left:0; width:100%; height:100%; border: none;
        }

        /* The "Watching Completed" Overlay to hide suggestions */
        #completionOverlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 17, 23, 0.95); /* Dark background */
            display: none; /* Hidden until video ends */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            animation: fadeIn 0.5s ease-in-out;
        }

        .btn-assessment { 
            background-color: #238636; color: white; border: none; padding: 15px 40px; 
            border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px; 
            transition: 0.3s;
        }
        .btn-assessment:disabled { 
            background-color: #161b22; color: #484f58; border: 1px solid #30363d; cursor: not-allowed; 
        }
        #statusHint { margin-top: 15px; color: #8b949e; font-size: 14px; }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="lessonTitle">Loading Lesson...</h1>
        
        <div class="video-wrapper">
            <div id="player"></div>
            
            <div id="completionOverlay">
                <h2 style="color: #58a6ff; font-size: 2rem; display:flex; align-items:center; justify-content:center; gap:10px;"><svg class="ico success" aria-hidden="true" viewBox="0 0 24 24"><path d="M9 16.2 4.8 12 3.4 13.4 9 19l12-12-1.4-1.4z"/></svg>Watching Completed</h2>
                <p style="font-size: 1.2rem;">You have finished the lesson content.</p>
            </div>
        </div>
        
        <button id="assessmentBtn" class="btn-assessment" disabled onclick="window.location.href='assessment.html'">Take Assessment</button>
        <p id="statusHint">Finish the video to unlock the assessment.</p>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDnfIJQxO6mi2_NEGqXRGH5EAxeaNcb7qc",
            authDomain: "oneorigin-learning-hub.firebaseapp.com",
            projectId: "oneorigin-learning-hub",
            storageBucket: "oneorigin-learning-hub.firebasestorage.app",
            messagingSenderId: "4168147692",
            appId: "1:4168147692:web:43a1205a0af9770f633bc9"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let videoId = "";
        let courseId = "";
        let alreadyPassed = false;
        let currentUserEmail = "";

        const COURSE_PROGRESS_LOCAL_KEY = 'catalogCourseProgress';
        const WATCH_SAVE_INTERVAL_MS = 5000;
        const RESUME_MIN_SECONDS = 3;
        const RESUME_END_BUFFER_SECONDS = 6;

        let player = null;
        let resumeSeconds = 0;
        let watchTick = null;
        let lastPersistedAt = 0;
        let watchMaxSeconds = 0;

        function clampNumber(n, min, max) {
            const x = Number(n);
            if (!Number.isFinite(x)) return min;
            return Math.min(max, Math.max(min, x));
        }

        function loadCatalogProgressLocal() {
            try {
                const raw = localStorage.getItem(COURSE_PROGRESS_LOCAL_KEY);
                const parsed = raw ? JSON.parse(raw) : {};
                return parsed && typeof parsed === 'object' ? parsed : {};
            } catch (_) {
                return {};
            }
        }

        function saveCatalogProgressLocal(map) {
            try {
                localStorage.setItem(COURSE_PROGRESS_LOCAL_KEY, JSON.stringify(map || {}));
            } catch (_) {}
        }

        async function readRemoteUserCourse(email, videoId) {
            const safeEmail = String(email || '').trim();
            const vid = String(videoId || '').trim();
            if (!safeEmail || !vid) return null;
            try {
                const ref = doc(db, 'userCourses', `${safeEmail}_${vid}`);
                const snap = await getDoc(ref);
                if (!snap.exists()) return null;
                return snap.data() || null;
            } catch (_) {
                return null;
            }
        }

        async function upsertCourseProgress(email, videoId, patch) {
            const safeEmail = String(email || '').trim();
            const vid = String(videoId || '').trim();
            if (!vid) return;

            // Local fallback (shared with dashboard)
            const map = loadCatalogProgressLocal();
            const existing = map[vid] && typeof map[vid] === 'object' ? map[vid] : {};
            const next = { ...existing, ...patch, videoId: vid };
            map[vid] = next;
            saveCatalogProgressLocal(map);

            // Firestore best-effort (use same collection as dashboard)
            if (!safeEmail) return;
            try {
                const ref = doc(db, 'userCourses', `${safeEmail}_${vid}`);
                await setDoc(ref, {
                    email: safeEmail,
                    ...patch,
                    videoId: vid,
                    updatedAt: new Date().toISOString()
                }, { merge: true });
            } catch (_) {}
        }

        async function getMergedProgress(email, videoId) {
            const vid = String(videoId || '').trim();
            if (!vid) return {};
            const local = loadCatalogProgressLocal();
            const localRow = local[vid] && typeof local[vid] === 'object' ? local[vid] : {};
            const remoteRow = await readRemoteUserCourse(email, vid);
            return { ...localRow, ...(remoteRow || {}) };
        }

        async function getSavedResumeSeconds(email, videoId) {
            const p = await getMergedProgress(email, videoId);
            const watch = (p && typeof p === 'object') ? (p.watch || {}) : {};
            const fromLast = Number(watch.lastSeconds);
            const fromMax = Number(watch.maxSeconds);
            const dur = Number(watch.durationSeconds);
            const base = Number.isFinite(fromLast) ? fromLast : (Number.isFinite(fromMax) ? fromMax : 0);
            const upper = Number.isFinite(dur) && dur > 0 ? Math.max(0, dur - RESUME_END_BUFFER_SECONDS) : 1e12;
            return clampNumber(base, 0, upper);
        }

        async function persistWatchPosition({ videoId, lastSeconds, maxSeconds, durationSeconds, completed }) {
            const vid = String(videoId || '').trim();
            if (!vid) return;
            const patch = {
                watch: {
                    lastSeconds: Math.max(0, Number(lastSeconds) || 0),
                    maxSeconds: Math.max(0, Number(maxSeconds) || 0),
                    durationSeconds: Math.max(0, Number(durationSeconds) || 0),
                    completed: completed === true
                }
            };
            await upsertCourseProgress(currentUserEmail, vid, patch);
        }

        onAuthStateChanged(auth, async user => {
            if(!user) return;
            currentUserEmail = user.email || '';
            courseId = localStorage.getItem("selectedCourseId") || '';
            
            // 1. Check if user already passed
            const progRef = doc(db, "userProgress", user.email, "completedCourses", courseId);
            const progSnap = await getDoc(progRef);
            if(progSnap.exists() && progSnap.data().status === "Passed") {
                alreadyPassed = true;
                document.getElementById('statusHint').innerText = "Assessment Locked: Course already completed.";
            }

            // 2. Fetch Course Video Data
            const courseSnap = await getDoc(doc(db, "courses", courseId));
            if(courseSnap.exists()){
                videoId = courseSnap.data().videoId;
                document.getElementById('lessonTitle').innerText = courseSnap.data().title;

                // Resume (do not resume when already passed)
                resumeSeconds = alreadyPassed ? 0 : await getSavedResumeSeconds(currentUserEmail, videoId);

                // Ensure we only load the API once we have state ready
                loadYoutubeAPI();
            }
        });

        function loadYoutubeAPI() {
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            document.head.appendChild(tag);
        }

        window.onYouTubeIframeAPIReady = () => {
            player = new YT.Player('player', {
                videoId: videoId,
                playerVars: { 
                    'rel': 0,               // Minimize related videos
                    'modestbranding': 1,    // Hide YT Logo
                    'iv_load_policy': 3     // Hide annotations
                },
                events: {
                    'onReady': async () => {
                        try {
                            const dur = Number(player?.getDuration?.() || 0);
                            if (Number.isFinite(dur) && dur > 0 && resumeSeconds > 0) {
                                const clamped = clampNumber(resumeSeconds, 0, Math.max(0, dur - RESUME_END_BUFFER_SECONDS));
                                if (clamped >= RESUME_MIN_SECONDS) {
                                    player.seekTo(clamped, true);
                                }
                            }
                        } catch (_) {}

                        // Start persistence tick loop
                        if (watchTick) clearInterval(watchTick);
                        watchTick = setInterval(async () => {
                            try {
                                if (!player || typeof player.getPlayerState !== 'function') return;
                                const state = player.getPlayerState();
                                if (state !== YT.PlayerState.PLAYING) return;

                                const now = Date.now();
                                if (now - lastPersistedAt < WATCH_SAVE_INTERVAL_MS - 250) return;
                                lastPersistedAt = now;

                                const cur = Number(player.getCurrentTime?.() || 0);
                                const dur = Number(player.getDuration?.() || 0);
                                if (!Number.isFinite(cur) || cur < 0) return;
                                if (Number.isFinite(dur) && dur > 0) {
                                    watchMaxSeconds = Math.max(watchMaxSeconds, Math.min(cur, dur));
                                } else {
                                    watchMaxSeconds = Math.max(watchMaxSeconds, cur);
                                }

                                const completed = Number.isFinite(dur) && dur > 0
                                    ? (cur >= Math.max(0, dur - 2))
                                    : false;

                                await persistWatchPosition({
                                    videoId,
                                    lastSeconds: cur,
                                    maxSeconds: watchMaxSeconds,
                                    durationSeconds: dur,
                                    completed
                                });
                            } catch (_) {}
                        }, 1000);
                    },
                    'onStateChange': (event) => {
                        // event.data == 0 means the video has "Ended"
                        if(event.data === 0) {
                            // 1. Show the "Watching Completed" message overlay
                            document.getElementById('completionOverlay').style.display = "flex";

                            // Persist completion + final timestamp
                            (async () => {
                                try {
                                    const cur = Number(player?.getCurrentTime?.() || 0);
                                    const dur = Number(player?.getDuration?.() || 0);
                                    watchMaxSeconds = Math.max(watchMaxSeconds, Number.isFinite(dur) && dur > 0 ? Math.min(cur, dur) : cur);
                                    await persistWatchPosition({
                                        videoId,
                                        lastSeconds: cur,
                                        maxSeconds: watchMaxSeconds,
                                        durationSeconds: dur,
                                        completed: true
                                    });
                                } catch (_) {}
                            })();
                            
                            // 2. Unlock assessment if they haven't passed yet
                            if(!alreadyPassed) {
                                document.getElementById('assessmentBtn').disabled = false;
                                document.getElementById('statusHint').innerText = "Video complete! You can now proceed.";
                            }
                        }

                        // Persist on pause/buffer for best-effort resume
                        if (event.data === 2 || event.data === 3) {
                            (async () => {
                                try {
                                    const cur = Number(player?.getCurrentTime?.() || 0);
                                    const dur = Number(player?.getDuration?.() || 0);
                                    watchMaxSeconds = Math.max(watchMaxSeconds, Number.isFinite(dur) && dur > 0 ? Math.min(cur, dur) : cur);
                                    await persistWatchPosition({
                                        videoId,
                                        lastSeconds: cur,
                                        maxSeconds: watchMaxSeconds,
                                        durationSeconds: dur,
                                        completed: false
                                    });
                                } catch (_) {}
                            })();
                        }
                    }
                }
            });
        };

        window.addEventListener('beforeunload', () => {
            try {
                if (!player || !videoId) return;
                const cur = Number(player.getCurrentTime?.() || 0);
                const dur = Number(player.getDuration?.() || 0);
                watchMaxSeconds = Math.max(watchMaxSeconds, Number.isFinite(dur) && dur > 0 ? Math.min(cur, dur) : cur);
                persistWatchPosition({
                    videoId,
                    lastSeconds: cur,
                    maxSeconds: watchMaxSeconds,
                    durationSeconds: dur,
                    completed: false
                });
            } catch (_) {}
        });
    </script>
</body>
</html>